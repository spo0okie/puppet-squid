#
# Файл кастомной конфигурации puppet-squid:
#

# Локальные адреса
acl localnet src 0.0.0.1-0.255.255.255	# RFC 1122 "this" network (LAN)
acl localnet src 10.0.0.0/8		# RFC 1918 local private network (LAN)
acl localnet src 100.64.0.0/10		# RFC 6598 shared address space (CGN)
acl localnet src 169.254.0.0/16 	# RFC 3927 link-local (directly plugged) machines
acl localnet src 172.16.0.0/12		# RFC 1918 local private network (LAN)
acl localnet src 192.168.64.0/18	# 192.168.64.1 - 192.168.127.254 - включает рабочие сети и не включает гостевые
acl localnet src fc00::/7       	# RFC 4193 local private network range
acl localnet src fe80::/10      	# RFC 4291 link-local (directly plugged) machines

#Гостевая сеть
acl localnet src 192.168.1.0/24		# WiFi VLAN

# Порты
acl SSL_ports port 443		# https
acl Safe_ports port 80		# http
acl Safe_ports port 21		# ftp
acl Safe_ports port 443		# https
acl Safe_ports port 70		# gopher
acl Safe_ports port 210		# wais
acl Safe_ports port 280		# http-mgmt
acl Safe_ports port 488		# gss-http
acl Safe_ports port 591		# filemaker
acl Safe_ports port 777		# multiling http

#unregistered ports - по умолчанию закрыто, т.к. открывает много левого. 
#можно прицельно открыть нужное белыми списками
#acl Safe_ports port 1025-65535	

acl CONNECT method CONNECT

#
# Recommended minimum Access Permission configuration:
#
# Deny requests to certain unsafe ports

http_access allow localhost manager
http_access deny !Safe_ports
http_access deny CONNECT !SSL_ports
http_access deny manager

# We strongly recommend the following be uncommented to protect innocent
# web applications running on the proxy server who think the only
# one who can access services on "localhost" is a local user
#http_access deny to_localhost

#
# INSERT YOUR OWN RULE(S) HERE TO ALLOW ACCESS FROM YOUR CLIENTS
#

# объявляем черные и белые списки 
acl white-list	url_regex -i "/etc/squid/url-list/white.txt"
acl fun			url_regex -i "/etc/squid/url-list/fun.txt"
acl proxy		url_regex -i "/etc/squid/url-list/proxy.txt"
acl ads			url_regex -i "/etc/squid/url-list/ads.txt"
acl fshares		url_regex -i "/etc/squid/url-list/fshares.txt"
acl games		url_regex -i "/etc/squid/url-list/games.txt"
acl porn		url_regex -i "/etc/squid/url-list/porn.txt"
acl soc			url_regex -i "/etc/squid/url-list/soc.txt"
acl dating		url_regex -i "/etc/squid/url-list/dating.txt"
acl updates		url_regex -i "/etc/squid/url-list/updates.txt"

#на белые списки ходить можно
http_access allow white-list all

#на черные нет
http_access deny fun all		#развлекательные сайты
http_access deny proxy all		#прокси, анонимайзеры
http_access deny ads all		#реклама
http_access deny fshares all	#файлообменники
http_access deny games all		#игры
http_access deny porn all		#порно
http_access deny soc all		#соцсети
http_access deny dating all		#знакомства
http_access deny updates all	#обновления


# Разрешаем ходить из локалки и гостевой сети
http_access allow localnet
http_access allow localhost

# Все остальное запрещаем
http_access deny all

# Слушаем порты
# 3128 - для указания вручную
# 3129 - HTTP для перехвата (прозрачное проксирование)
# 3130 - HTTPS для перехвата (прозрачное проксирование)
http_port  3128	
http_port  3129 intercept
https_port 3130 intercept ssl-bump connection-auth=off cert=/etc/squid/squidCA.pem 


sslproxy_cert_error allow all
tls_outgoing_options flags=DONT_VERIFY_PEER

#список блокируемых ресурсов. 
#(ресурс идентифицируется подклядываением сертификат какого домена используется в HTTPS соединении)
#поэтому список - это список доменов может тут есть возможность regexp, но я не вкурсе
acl block1ssl ssl::server_name_regex "/etc/squid/url-list/full.lst"

# краткая справка:
# И для каждого из этих этапов можно определить, что Squid будет делать c запросами клиентов:
# splice - пропустить все последующие действия, т.е. просто поднимаем TCP-туннель, словно и нет никакого ssl-bump
# peek — подсмотреть всю доступную информацию без "влезания" в соединение
# terminate — закрыть соединение
# bump — "влезть" в соединение, сделать https видимым как http
# SslBump1 - получение открытой информации о соединении (из сертификатов и http-запроса);
# SslBump2 - передача Hello info клиента (создание соединения с сервером);
# SslBump3 - получение Hello info сервера (создание соединения с клиентом).

# Реализация фильтрации черных списков без MITM атаки: 
# идея содрана тут: https://habr.com/ru/post/267851/
# немного взято отсюда: https://forum.lissyara.su/freebsd-f8/freebsd-11-squid-4-5-prozrachnoe-proksirovanie-s-p-t45437.html

# Мы просто подглядываем каким сертификатом подписаны запросы, не вмешиваясь в этот диалог, если все ок
# Но если все не ок (соединение подписано сертификатом домена из чернго списка), то про дропаем соединение
# Т.е. тут вмешиваемся, но без генерирования сертификатов и всего такого что обычно бывает при
# MITM в HTTPS
acl step1 at_step SslBump1		# создать еще правило  с именем step1 для получения открытой информацией
ssl_bump peek step1				# подсмотреть всю доступную информацию без "влезания" в соединение
ssl_bump terminate block1ssl	# здесь блочить все что указано в файле в правиле ssl.txt см. выше
ssl_bump splice all				#  пропустить все последующие действия для всех

#т.е. мы или только подглядываем, или прям экстерминатус

#как я понимаю это утилита, которая должна генерить сертификаты для MITM
sslcrtd_program /usr/lib64/squid/security_file_certgen -s /var/lib/ssl_db -M 4MB

# Uncomment and adjust the following to add a disk cache directory.
#cache_dir ufs /var/spool/squid 100 16 256

# Leave coredumps in the first cache dir
coredump_dir /var/spool/squid

#
# Add any of your own refresh_pattern entries above these.
#
refresh_pattern ^ftp:		1440	20%	10080
refresh_pattern ^gopher:	1440	0%	1440
refresh_pattern -i (/cgi-bin/|\?) 0	0%	0
refresh_pattern .		0	20%	4320
